#!/usr/bin/env python3

import subprocess
import re
from rich import print
from rich.table import Table

# List of insecure/sensitive libc functions and variants
insecure_functions = {
    "_strcpy": "Unsafe string copy (no bounds)",
    "_strncpy": "Tricky: may not null-terminate",
    "_strncat": "Risk of overflow if size unchecked",
    "_memcpy": "Can overwrite memory",
    "_vsnprintf": "Safe if used properly",
    "_printf": "Format string vulnerability risk",
    "_sscanf": "Can cause overflows with bad format",
    "_fopen": "Risky file access if input not sanitized",
    "_stat": "File metadata disclosure",
    "_strlen": "Neutral unless pointer is tainted",
    "_sprintf": "Dangerous – prefer snprintf",
    "_gets": "Very unsafe (deprecated)",
    "_system": "Command execution risk",
    "_malloc": "Risk of memory issues if input-controlled or misused",
    "_popen": "Command injection risk"
}

# Greedy pattern to catch function name variants
regex_pattern = re.compile("|".join(map(re.escape, insecure_functions.keys())))

def extract_strings(file_path):
    try:
        result = subprocess.run(["strings", file_path], capture_output=True, text=True, check=True)
        return result.stdout.splitlines()
    except subprocess.CalledProcessError as e:
        print(f"[red]Error running strings on binary: {e}[/red]")
        return []

def find_insecure_apis(strings_output):
    findings = {}
    for line in strings_output:
        match = regex_pattern.search(line)
        if match:
            func = match.group()
            findings[func] = insecure_functions.get(func, "Potentially insecure API")
    return findings

def display_table(findings):
    table = Table(title="Insecure C Functions Found in Binary", style="bold cyan")
    table.add_column("Function", style="bold red")
    table.add_column("Risk Description", style="white")

    for func, desc in sorted(findings.items()):
        table.add_row(func, desc)

    print(table)

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("[yellow]Usage:[/yellow] python3 ios_insecure_api_checker.py <path-to-binary>")
        sys.exit(1)

    binary_path = sys.argv[1]
    print(f"\n[bold green]Analyzing:[/bold green] {binary_path}\n")

    strings_output = extract_strings(binary_path)
    findings = find_insecure_apis(strings_output)

    if findings:
        display_table(findings)
    else:
        print("[green]✅ No insecure libc functions found![/green]")
